-- 3. add_customer: 
create procedure add_customer(custname text, homeaddress text, contactnumber integer, custemail text, creditcardnum integer, cardexpirydate date, cardcvv integer)
    language plpgsql
as
$$
DECLARE
    custId INT;
BEGIN
    custId := 11;
    INSERT INTO Customers VALUES (custId, homeAddress, contactNumber, custName, custEmail);
    INSERT INTO Credit_cards VALUES (creditCardNum, cardCVV, cardExpiryDate, NULL, custId);
END;
$$;







-- 4. update_credit_card: 
CREATE OR REPLACE PROCEDURE update_credit_card
    (custId INT, creditCardNum INTEGER, cardExpiryDate DATE, cardCVV INTEGER)
    AS $$
BEGIN
    UPDATE Credit_cards
    SET credit_card_num = creditCardNum,
        cvv = cardCVV,
        card_expiry_date = cardExpiryDate
    WHERE  cust_id = custId;
END;
$$ LANGUAGE plpgsql;


-- 5. add_course: 
--  This routine is used to add a new course. 
--  inputs: course title, course description, course area, and duration(in terms of hours).
--  The course identifier is generated by the system.
create procedure add_course(title text, course_description text, course_area_name text, duration integer)
    language plpgsql
as
$$
DECLARE
    id INT;
BEGIN
    SELECT MAX(course_id) + 1 INTO id FROM Courses;
    INSERT INTO Courses (course_id,course_area_name,title,course_description,duration)
    VALUES (id,course_area_name,title,course_description,duration);
END;
$$;





-- 6. find_instructors
--  This routine is used to find all the instructors who could be assigned to teach a course session.
--  inputs: course identifier, session date, and session start hour. 
--  The routine returns a table of records consisting of employee identifier and name.
create function find_instructors(find_course_id integer, find_session_date date, find_start_time time without time zone)
    returns TABLE(eid integer, emp_name text)
    language sql
as
$$
SELECT eid,emp_name
    FROM (Specialises NATURAL JOIN Courses NATURAL JOIN Instructors NATURAL JOIN Employees) T
    WHERE T.course_id = find_course_id
    -- filter out instructors that have lessons during the start time 
    AND T.eid NOT IN (
        SELECT C.eid 
        FROM Course_Sessions C
        where C.session_date = find_session_date
        and C.eid = T.eid
        and 
        (
        -- start_time between the range
        (extract(hours from C.start_time) <= extract(hours from find_start_time) + 1
         and extract(hours from find_start_time) + 1 <= C.end_time)
        or
        (   
            -- end time between the range
            extract(hours from C.start_time) <= extract(hours from find_start_time) + T.duration + 1
            and
            extract(hours from find_start_time) + T.duration + 1 <=  extract(hours from C.end_time)
        )
        )
    )
$$;


-- 7. get_available_instructors
-- This routine is used to retrieve the availability information of instructors who could be assigned to teach a specified course. 
--  inputs: course identifier, start date, and end date. 
-- output:SETS OF (eid, name,total number of teaching hours
--  that the instructor has been assigned for this month, day 
-- (which is within the input date range [start date, end date]), 
-- and an array of the available hours for the instructor on the specified day. 
-- output: sorted in ascending order of employee identifier and day, and the array entries are sorted in ascending order of hour.
create function get_available_instructors(find_course_id integer, find_start_date date, find_end_date date)
    returns TABLE(emp_id integer, emp_name text, teaching_hours integer, day_available date, hours_arr time without time zone[])
    language plpgsql
as
$$
-- sessions 1h apart from each other
DECLARE 
    curs CURSOR FOR (
                    SELECT *  FROM Instructors natural join Employees natural join Specialises natural join  courses T 
                    WHERE T.course_id = find_course_id);
    possible_date DATE;
    days_arr DATE[];
    r RECORD;
    possible_hour TIME;
    possible_hours TIME[];
    total_sessions int;
    session_duration int;
BEGIN
    OPEN curs;
    LOOP
        FETCH curs into r;
        EXIT WHEN NOT FOUND;
        emp_id := r.eid;
        emp_name := r.emp_name;
        days_arr := ARRAY(
                SELECT day::date
                FROM generate_series( find_start_date, find_end_date, '1 day') day
            );
        -- Loop through all possible days
        FOREACH possible_date SLICE 0 IN ARRAY days_arr
        LOOP
            day_available := possible_date;
            --Loop through all possible hours
            hours_arr := '{}';
            possible_hours := '{09:00,10:00,11:00,13:00,14:00,15:00,16:00,17:00}';
            FOREACH possible_hour in ARRAY possible_hours
            LOOP
                 IF EXISTS (
                  SELECT T.eid
                  FROM find_instructors(find_course_id,possible_date,possible_hour) T
                  WHERE  T.eid = emp_id
                  ) THEN
                    hours_arr := array_append(hours_arr, possible_hour);
                END IF;
            END LOOP;

            -- we get total number of teaching hours that the instructor has been assigned for this month
            SELECT COUNT(*) INTO total_sessions
            FROM (Course_Sessions NATURAL JOIN Courses) C
            group by C.eid;

            SELECT duration INTO session_duration
            FROM Courses NATURAL JOIN Course_Sessions T
            WHERE T.eid = emp_id;

            teaching_hours := total_sessions * session_duration;


            RETURN  NEXT;

        END LOOP;

    END LOOP;
    END;
$$;

alter function get_available_instructors(integer, date, date) owner to kimguan;




-- 8. find_rooms: This routine is used to find all the rooms that could be used for a course session. 
-- The inputs to the routine include the following: 
-- session date, session start hour, and session duration. 
-- The routine returns a table of room identifiers.
CREATE OR REPLACE FUNCTION find_rooms
-- ASSUMPTION: DURATION IN HOURS
(IN find_session_date DATE,IN find_start_time TIME,IN find_duration INTEGER)
RETURNS TABLE(rid INTEGER) AS $$
    SELECT R.rid
    FROM Rooms R
    -- exclude rooms occupied during start time
    -- and rooms occupied where duration overlaps
    EXCEPT
    SELECT C.rid
    FROM Course_Sessions C
    WHERE C.session_date = find_session_date
    AND (
    (C.start_time < find_start_time and find_start_time < C.end_time)
    OR
    -- and rooms occupied where duration overlaps
    (extract(hour from start_time) + find_duration > C.start_time)
    );
END
$$ LANGUAGE SQL





